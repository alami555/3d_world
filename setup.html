<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple 3D Physics</title>
<style>
    body { margin: 0; }
    canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ammo.js@latest/builds/ammo.wasm.js"></script>
<script>
    let scene, camera, renderer, physicsWorld, rigidBodies = [];
    let tmpTrans;

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 20);

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        initPhysics();

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(0, 5, 0);
        scene.add(cube);

        cube.userData.physicsBody = new Ammo.btRigidBody(
            new Ammo.btRigidBodyConstructionInfo(
                1,
                new Ammo.btDefaultMotionState(new Ammo.btTransform().setIdentity()),
                new Ammo.btBoxShape(new Ammo.btVector3(0.5, 0.5, 0.5)),
                new Ammo.btVector3(0, 10, 0)
            )
        );
        rigidBodies.push(cube);
    }

    function initPhysics() {
        let collisionConfiguration = new Ammo.btDefaultCollisionConfiguration(),
            dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration),
            overlappingPairCache = new Ammo.btDbvtBroadphase(),
            solver = new Ammo.btSequentialImpulseConstraintSolver();

        physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
        physicsWorld.setGravity(new Ammo.btVector3(0, -10, 0));

        for (let i = 0; i < rigidBodies.length; i++) {
            physicsWorld.addRigidBody(rigidBodies[i].userData.physicsBody);
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        physicsWorld.stepSimulation(1 / 60, 10);

        for (let i = 0; i < rigidBodies.length; i++) {
            let objThree = rigidBodies[i];
            let objPhys = objThree.userData.physicsBody;
            let ms = objPhys.getMotionState();
            if (ms) {
                let p = ms.getWorldTransform(tmpTrans).getOrigin();
                objThree.position.set(p.x(), p.y(), p.z());
                let q = ms.getWorldTransform(tmpTrans).getRotation();
                objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
            }
        }

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
